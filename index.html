<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Undertale Battle Template</title>
    <style>
        @font-face {
            font-family: 'Determination Mono';
            src: url('./Fonts/DTM-Mono.otf') format('opentype'),
                 url('./Fonts/DTM-Mono.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'Determination Sans';
            src: url('./Fonts/DTM-Sans.otf') format('opentype'),
                url('./Fonts/DTM-Sans.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            image-rendering: pixelated;
            cursor: none !important; /* Disable mouse cursor */
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            color: white;
            font-family: 'Determination Mono', monospace;
            -webkit-font-smoothing: none;
        }

        #game-container {
            width: 640px;
            height: 480px;
            position: relative;
            border: 1px solid #444;
            background-color: #000;
            overflow: hidden;
            font-family: 'Determination Mono', monospace;
            font-smooth: never;
            -webkit-font-smoothing: none;
        }

        #battle-area {
            width: 100%;
            padding-top: 40px; /* Moved monsters up */
            position: relative;
        }

        #monster-container {
            width: 422px;
            height: 140px;
            margin: 0 auto;
            position: relative;
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        .monster {
            image-rendering: pixelated;
            position: relative;
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 32px;
        }

        #text-box {
            width: 622px;
            height: 155px;
            margin: 0px auto 0;
            border: 4px solid white;
            position: relative;
        }

        #text-content {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 22px;
            white-space: pre;
            letter-spacing: 1px;
        }

        #player-info {
            width: 500px;
            margin: 20px auto 0;
            margin-left: 30px;
            display: flex;
            align-items: center;
        }

        #player-name-lv {
            font-size: 22px;
            letter-spacing: 1px;
            margin-right: 20px;
        }

        #hp-section {
            display: flex;
            align-items: center;
        }

        .hp-text {
            margin-right: 10px;
            font-size: 22px;
            letter-spacing: 1px;
        }

        .hp-gauge-container {
            width: 90px;
            height: 20px;
            background-color: red;
            border: none;
        }

        .hp-gauge {
            height: 100%;
            background-color: yellow;
            width: 100%; /* Full health */
        }

        .hp-numbers {
            margin-left: 10px;
            font-size: 22px;
            letter-spacing: 1px;
            
        }

        #buttons {
            position: absolute;
            bottom: 20px; /* Move buttons lower */
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 10px; /* Smaller gap between buttons */
        }

        /* Button styling for image buttons */
        .battle-btn {
            background-color: transparent;
            border: none;
            cursor: none !important; /* Disable mouse cursor */
            padding: 0;
            display: inline-block;
            image-rendering: pixelated;
        }

        .battle-btn img {
            display: block;
            image-rendering: pixelated;
            width: 140px; /* Fixed width for all button images */
            height: auto; /* Fixed height for all button images */
        }

        #battle-box {
            position: absolute;
            width: 120px;
            height: 120px;
            border: 4px solid white;
            left: 50%;
            top: 55%;
            transform: translate(-50%, -50%);
            display: none;
        }

        #player-soul {
            position: absolute;
            width: 16px;
            height: 16px;
            background-color: red;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Attack animation for bullet patterns */
        .bullet {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: white;
            image-rendering: pixelated;
        }

        /* Start screen styles */
        #start-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #start-text {
            font-family: 'Determination Mono', monospace;
            font-size: 24px;
            color: white;
            text-align: center;
            margin-bottom: 20px;
        }

        #press-z {
            font-family: 'Determination Mono', monospace;
            font-size: 18px;
            color: white;
            text-align: center;
            position: relative;
            animation: blink 1s infinite;
        }

        /* Menu selection styles */
        .menu-option {
            position: relative;
            margin-left: 30px;
            margin-bottom: 10px;
        }

        .menu-option.selected:before {
            content: '‚ô•';
            position: absolute;
            left: -30px;
            color: red;
        }

        /* Monster selection styles */
        .monster-option {
            position: relative;
            margin-left: 30px;
            margin-bottom: 10px;
        }

        .monster-option.selected:before {
            content: '‚ô•';
            position: absolute;
            left: -30px;
            color: red;
        }

        /* Attack animation */
        .slash {
            position: absolute;
            width: 80px;
            height: 4px;
            background-color: white;
            transform: rotate(45deg);
            display: none;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        /* Cross-browser compatibility fix for colors */
        .hp-gauge {
            background-color: rgb(255, 255, 0) !important; /* Force proper yellow */
        }
        
        .hp-gauge-container {
            background-color: rgb(255, 0, 0) !important; /* Force proper red */
        }
        
        #player-soul {
            background-color: rgb(255, 0, 0) !important; /* Force proper red */
        }
    </style>
</head>
<body>
    <!-- Audio elements -->
    <audio id="buttonMoveSound" src="sounds/buttonMove.mp3" preload="auto"></audio>
    <audio id="encounterSound" src="sounds/encounter.mp3" preload="auto"></audio>
    <audio id="textSound" src="sounds/text.mp3" preload="auto" loop></audio>
    <audio id="damageTakenSound" src="sounds/damageTaken.mp3" preload="auto"></audio>
    <audio id="attackSound" src="sounds/attack.mp3" preload="auto"></audio>
    <audio id="healSound" src="sounds/heal.mp3" preload="auto"></audio>

    <div id="game-container">
        <!-- Start screen -->
        <div id="start-screen">
            <div id="start-text">UNDERTALE: Beyond The Story</div>
            <div id="press-z" style="color: yellow;">Press Z to start</div>
        </div>

        <div id="battle-area">
            <div id="monster-container">
                <div id="monster1" class="monster">üëÅÔ∏è</div>
                <div id="monster2" class="monster">ü•ï</div>
                <div id="monster3" class="monster">üêú</div>
            </div>
        </div>
        
        <div id="text-box">
            <div id="text-content">* Maple, Chara and Anti block the
way!</div>

            <!-- Option menus (initially hidden) -->
            <div id="fight-menu" style="display: none;">
                <div class="monster-option selected" data-index="0">* Maple</div>
                <div class="monster-option" data-index="1">* Chara</div>
                <div class="monster-option" data-index="2">* Anti</div>
            </div>

            <div id="act-menu" style="display: none;">
                <div class="menu-option selected" data-index="0">* Check</div>
                <div class="menu-option" data-index="1">* Pray</div>
                <div class="menu-option" data-index="2">* Defend</div>
                <div class="menu-option" data-index="3">* Control</div>
            </div>

            <div id="act-monster-menu" style="display: none;">
                <div class="monster-option selected" data-index="0">* Maple</div>
                <div class="monster-option" data-index="1">* Chara</div>
                <div class="monster-option" data-index="2">* Anti</div>
            </div>

            <div id="item-menu" style="display: none;">
                <div class="menu-option selected" data-index="0">* Holy Water (heals 22 HP)</div>
                <div class="menu-option" data-index="1">* His Blood (heals 50 HP)</div>
                <div class="menu-option" data-index="2">* His Body (heals 100 HP)</div>
            </div>

            <div id="mercy-menu" style="display: none;">
                <div class="menu-option selected" data-index="0">* SPARE</div>
                <div class="menu-option" data-index="1">* FLEE</div>
            </div>
        </div>
        
        <div id="player-info">
            <div id="player-name-lv">ICARUS LV 2</div>
            <div id="hp-section">
                <span class="hp-text">HP</span>
                <div class="hp-gauge-container">
                    <div class="hp-gauge"></div>
                </div>
                <span class="hp-numbers">20/20</span>
            </div>
        </div>
        
        <div id="buttons">
            <button id="fight-btn" class="battle-btn">
                <img src="img/fight.png" alt="Fight">
            </button>
            <button id="act-btn" class="battle-btn">
                <img src="img/act.png" alt="Act">
            </button>
            <button id="item-btn" class="battle-btn">
                <img src="img/item.png" alt="Item">
            </button>
            <button id="mercy-btn" class="battle-btn">
                <img src="img/mercy.png" alt="Mercy">
            </button>
        </div>
        
        <div id="battle-box">
            <div id="player-soul"></div>
            <!-- Bullets and attacks will be added here dynamically -->
        </div>

        <!-- Slash animation for attack -->
        <div class="slash"></div>
    </div>

    <script>
        // Game configuration
        const config = {
            currentState: 'START_SCREEN', // START_SCREEN, INTRO, PLAYER_CHOICE, FIGHT, ACT, ITEM, MERCY, ENEMY_TURN
            currentSelectedButton: 0, // 0: FIGHT, 1: ACT, 2: ITEM, 3: MERCY
            currentSelectedOption: 0, // Selected index in submenus
            currentSelectedMonster: 0, // Selected monster in target selection
            currentActionType: '', // FIGHT, CHECK, PRAY, DEFEND, CONTROL, ITEM, SPARE, FLEE
            gameStarted: false,
            monsters: [
                {
                    name: 'Maple',
                    hp: 50,
                    maxHp: 50,
                    sprite: 'üëÅÔ∏è', // Placeholder - replace with pixel art image
                    acts: ['Check', 'Talk'],
                    position: { x: 100, y: 100 }
                },
                {
                    name: 'Chara',
                    hp: 40,
                    maxHp: 40,
                    sprite: 'ü•ï', // Placeholder - replace with pixel art image
                    acts: ['Check', 'Talk'],
                    position: { x: 250, y: 100 }
                },
                {
                    name: 'Anti',
                    hp: 30,
                    maxHp: 30,
                    sprite: 'üêú', // Placeholder - replace with pixel art image
                    acts: ['Check', 'Talk'],
                    position: { x: 400, y: 100 }
                }
            ],
            player: {
                name: 'ICARUS',
                lv: 2,
                hp: 20,
                maxHp: 20,
                x: 320, // Center position for the soul
                y: 240,
                speed: 3,
                defense: 0 // Added for the Defend action
            },
            items: [
                { name: 'Holy Water', healAmount: 22 },
                { name: 'His Blood', healAmount: 50 },
                { name: 'His Body', healAmount: 100 }
            ],
            dialogues: {
                intro: '* Maple, Chara and Anti block\n  the way!',
                mapleCheck: '* MAPLE - ATK 5 DEF 4\n* Just wants to have fun.',
                charaCheck: '* CHARA - ATK 6 DEF 3\n* Determined to fight.',
                antiCheck: '* ANTI - ATK 4 DEF 5\n* Seeks to cause chaos.',
                act: {
                    'Check': {
                        0: '* MAPLE - ATK 5 DEF 4\n* Just wants to have fun.',
                        1: '* CHARA - ATK 6 DEF 3\n* Determined to fight.',
                        2: '* ANTI - ATK 4 DEF 5\n* Seeks to cause chaos.'
                    },
                    'Pray': '* You pray for salvation.\n* You recovered 5 HP.',
                    'Defend': '* You prepare to defend yourself.\n* DEF increased for this turn.',
                    'Control': '* You attempt to control the\n  monster... with no effect.',
                },
                spare: '* YOU WON!\n* You earned 0 XP and 20 gold.'
            },
            battleBox: {
                x: 210, // Centered position
                y: 240,
                width: 120, // Width of box
                height: 120 // Height of box
            },
            soundEffects: {
                buttonMove: document.getElementById('buttonMoveSound'),
                encounter: document.getElementById('encounterSound'),
                text: document.getElementById('textSound'),
                damageTaken: document.getElementById('damageTakenSound'),
                attack: document.getElementById('attackSound'),
                heal: document.getElementById('healSound')
            },
            isTyping: false,
            currentSubmenu: null
        };

        // DOM elements
        const startScreen = document.getElementById('start-screen');
        const gameContainer = document.getElementById('game-container');
        const textBox = document.getElementById('text-box');
        const battleButtons = document.querySelectorAll('.battle-btn');
        const playerSoul = document.getElementById('player-soul');
        const monsterContainer = document.getElementById('monster-container');
        const battleBox = document.getElementById('battle-box');
        const textContent = document.getElementById('text-content');
        const fightMenu = document.getElementById('fight-menu');
        const actMenu = document.getElementById('act-menu');
        const actMonsterMenu = document.getElementById('act-monster-menu');
        const itemMenu = document.getElementById('item-menu');
        const mercyMenu = document.getElementById('mercy-menu');
        const slash = document.querySelector('.slash');
        
        // Animation frame tracking
        let animationFrameId;
        let lastFrameTime = 0;
        
        // Undertale text typing effect variables
        let currentDialogue = '';
        let displayedText = '';
        let charIndex = 0;
        let textSpeed = 30; // ms per character
        let lastCharTime = 0;
        
        // Play sound function
        function playSound(sound) {
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(err => {
                    console.warn("Sound play failed:", err);
                });
            }
        }
        
        // Stop sound function
        function stopSound(sound) {
            if (sound) {
                sound.pause();
                sound.currentTime = 0;
            }
        }
        
        // Initialize monsters
        function initMonsters() {
            // Set up monsters with their positions and stats
            // In a full implementation, this would load sprite images
            const monsters = document.querySelectorAll('.monster');
            monsters.forEach((monster, index) => {
                if (config.monsters[index]) {
                    monster.textContent = config.monsters[index].sprite;
                }
            });
        }
        
        // Hide all menus
        function hideAllMenus() {
            fightMenu.style.display = 'none';
            actMenu.style.display = 'none';
            actMonsterMenu.style.display = 'none';
            itemMenu.style.display = 'none';
            mercyMenu.style.display = 'none';
            textContent.style.display = 'block';
        }
        
        // Handle menu navigation (FIGHT, ACT, ITEM, MERCY)
        function handleMenuNavigation(e) {
            if (e.key === 'ArrowLeft') {
                config.currentSelectedButton = Math.max(0, config.currentSelectedButton - 1);
                playSound(config.soundEffects.buttonMove);
                updateButtonSelection();
            }
            else if (e.key === 'ArrowRight') {
                config.currentSelectedButton = Math.min(3, config.currentSelectedButton + 1);
                playSound(config.soundEffects.buttonMove);
                updateButtonSelection();
            }
            else if (e.key === 'z' || e.key === 'Z' || e.key === 'Enter') {
                selectCurrentButton();
            }
        }
        
        // Update button selection visuals
        function updateButtonSelection() {
            battleButtons.forEach((button, index) => {
                const img = button.querySelector('img');
                const buttonType = ['fight', 'act', 'item', 'mercy'][index];
                
                if (index === config.currentSelectedButton) {
                    img.src = `img/${buttonType}Hover.png`;
                } else {
                    img.src = `img/${buttonType}.png`;
                }
            });
        }
        
        // Select current button action
        function selectCurrentButton() {
            switch(config.currentSelectedButton) {
                case 0:
                    enterFightMode();
                    break;
                case 1:
                    enterActMode();
                    break;
                case 2:
                    enterItemMode();
                    break;
                case 3:
                    enterMercyMode();
                    break;
            }
        }
        
        // Handle submenu selection (for FIGHT, ACT, etc)
        function handleSubMenu(e) {
            const menu = config.currentSubmenu;
            const menuOptions = menu.querySelectorAll(menu.id === 'fight-menu' || menu.id === 'act-monster-menu' ? '.monster-option' : '.menu-option');
            const maxIndex = menuOptions.length - 1;
            
            if (e.key === 'ArrowUp') {
                config.currentSelectedOption = (config.currentSelectedOption - 1 + menuOptions.length) % menuOptions.length;
                playSound(config.soundEffects.buttonMove);
                updateMenuSelection();
            }
            else if (e.key === 'ArrowDown') {
                config.currentSelectedOption = (config.currentSelectedOption + 1) % menuOptions.length;
                playSound(config.soundEffects.buttonMove);
                updateMenuSelection();
            }
            else if (e.key === 'z' || e.key === 'Z' || e.key === 'Enter') {
                selectCurrentMenuOption();
            }
            else if (e.key === 'x' || e.key === 'X' || e.key === 'Escape') {
                // Return to main menu
                hideAllMenus();
                config.currentState = 'PLAYER_CHOICE';
                setDialogueText('* What will you do?');
            }
        }
        
        // Update menu selection visuals
        function updateMenuSelection() {
            const menu = config.currentSubmenu;
            const menuOptions = menu.querySelectorAll(menu.id === 'fight-menu' || menu.id === 'act-monster-menu' ? '.monster-option' : '.menu-option');
            
            menuOptions.forEach((option, index) => {
                if (index === config.currentSelectedOption) {
                    option.classList.add('selected');
                } else {
                    option.classList.remove('selected');
                }
            });
        }
        
        // Select current menu option
        function selectCurrentMenuOption() {
            switch(config.currentState) {
                case 'FIGHT':
                    config.currentSelectedMonster = config.currentSelectedOption;
                    executeAttack();
                    break;
                case 'ACT_MONSTER_SELECT':
                    config.currentSelectedMonster = config.currentSelectedOption;
                    hideAllMenus();
                    actMenu.style.display = 'block';
                    config.currentSubmenu = actMenu;
                    config.currentSelectedOption = 0;
                    config.currentState = 'ACT';
                    updateMenuSelection();
                    break;
                case 'ACT':
                    executeAct();
                    break;
                case 'ITEM':
                    useItem();
                    break;
                case 'MERCY':
                    executeMercy();
                    break;
            }
        }
        
        // Disable all mouse interactions
        document.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            return false;
        }, true);
        
        // Global keyboard handler
        document.addEventListener('keydown', function(e) {
            // Log every key press to see if the listener is firing at all
            console.log("Key pressed:", e.key, "| Current State:", config.currentState, "| Game Started:", config.gameStarted);

            // --- Start Screen Logic ---
            if (config.currentState === 'START_SCREEN' && !config.gameStarted) {
                console.log("Attempting to start game check..."); // Check if we enter this block
                if (e.key === 'z' || e.key === 'Z' || e.key === 'Enter') {
                    console.log("Z/Enter detected on Start Screen!"); // Check if the key is correctly identified
                    e.preventDefault(); // Prevent default browser action (like scrolling for Enter)
                    startGame();
                    return; // IMPORTANT: Exit handler after starting the game
                } else {
                    console.log("Other key pressed on Start Screen, ignoring.");
                    return; // Ignore other keys on start screen
                }
            }

            // --- Game Has Started Logic ---
            // Only proceed if game has started AND we are NOT on the start screen anymore
            if (!config.gameStarted) {
                console.log("Game not started, ignoring key press.");
                return; // Exit if the game hasn't been initiated yet
            }

            // Handle different game states
            switch(config.currentState) {
                case 'PLAYER_CHOICE':
                    handleMenuNavigation(e);
                    break;
                case 'ENEMY_TURN':
                    handleSoulMovement(e);
                    break;
                case 'FIGHT':
                case 'ACT':
                case 'ACT_MONSTER_SELECT':
                case 'ITEM':
                case 'MERCY':
                    handleSubMenu(e);
                    break;
                default:
                    // Allow Z/Enter to progress dialogue ONLY if typing is finished
                    if(config.currentState !== 'INTRO' && !config.isTyping && (e.key === 'z' || e.key === 'Z' || e.key === 'Enter')) {
                       // Add logic here if needed for other states requiring Z press
                       console.log("Z pressed in state:", config.currentState);
                    } else if (config.currentState === 'INTRO' && (e.key === 'z' || e.key === 'Z' || e.key === 'Enter')) {
                         // Specifically handle progressing the intro dialogue
                         progressDialogue();
                    }
                    break;
            }
        });

        // Start the game function
        function startGame() {
            // Check if already started to prevent multiple initializations
            if (config.gameStarted) {
                console.warn("startGame called but game already started.");
                return;
            }
            console.log("startGame() function called!");

            // Hide start screen
            if (startScreen) {
                startScreen.style.display = 'none';
                console.log("Start screen hidden.");
            } else {
                console.error("Start screen element not found!");
                return; // Stop if the element is missing
            }

            // Set game state
            config.gameStarted = true;
            config.currentState = 'INTRO'; // Move to INTRO state first
            console.log("Game state set: gameStarted=true, currentState='INTRO'");

            // Play encounter sound
            try {
                if (config.soundEffects && config.soundEffects.encounter) {
                    playSound(config.soundEffects.encounter);
                    console.log("Encounter sound played.");
                } else {
                     console.warn("Encounter sound effect not found or configured.");
                }
            } catch (e) {
                console.error("Error playing encounter sound:", e);
            }

            // Initialize game elements
            try {
                console.log("Calling init()...");
                init(); // Calls the initialization function
                console.log("init() finished.");
            } catch (e) {
                console.error("Error during init():", e);
            }
        }

        // Progress dialogue function
        function progressDialogue() {
            console.log("progressDialogue called. Current State:", config.currentState, "Char Index:", charIndex, "Dialogue Length:", currentDialogue.length);
            if (config.isTyping && charIndex < currentDialogue.length) {
                // If text is still typing, complete it immediately
                console.log("Finishing typing dialogue...");
                displayedText = currentDialogue;
                charIndex = currentDialogue.length;
                document.getElementById('text-content').textContent = displayedText;

                // Stop text sound when dialogue is done
                stopSound(config.soundEffects.text);
                config.isTyping = false;
                 console.log("Dialogue typing force-finished.");
            } else if (!config.isTyping && charIndex >= currentDialogue.length) {
                // If text is finished, move to next state
                 console.log("Dialogue finished, checking state transition...");
                if(config.currentState === 'INTRO') {
                     console.log("Transitioning from INTRO to PLAYER_CHOICE");
                    config.currentState = 'PLAYER_CHOICE';
                    updateButtonSelection(); // Select the FIGHT button visually now
                    setDialogueText("* What will you do?"); // Set standard choice text (or keep intro text if preferred)
                } else {
                    console.log("Dialogue finished, but no state transition defined for state:", config.currentState);
                    // Handle other dialogue progressions if needed
                }
            } else {
                 console.log("progressDialogue called but typing already finished or not applicable.");
            }
        }

        // Undertale text typing effect
        function typeText() {
            const now = Date.now();
            
            if (charIndex < currentDialogue.length && now - lastCharTime > textSpeed) {
                if (!config.isTyping) {
                    // Start playing text sound when typing begins
                    playSound(config.soundEffects.text);
                    config.isTyping = true;
                }
                
                displayedText += currentDialogue.charAt(charIndex);
                charIndex++;
                document.getElementById('text-content').textContent = displayedText;
                lastCharTime = now;
            } else if (charIndex >= currentDialogue.length && config.isTyping) {
                // Stop text sound when typing is complete
                stopSound(config.soundEffects.text);
                config.isTyping = false;
            }
            
            requestAnimationFrame(typeText);
        }
        
        // Set new dialogue text with typing effect
        function setDialogueText(text) {
            currentDialogue = text;
            displayedText = '';
            charIndex = 0;
            lastCharTime = 0;
            
            // Make sure text sound stops when we set new text
            stopSound(config.soundEffects.text);
            config.isTyping = false;
        }
        
        // Soul movement during enemy turn
        function handleSoulMovement(e) {
            const speed = config.player.speed;
            const box = config.battleBox;
            
            // Calculate new position
            let newX = config.player.x;
            let newY = config.player.y;
            
            if(e.key === 'ArrowUp') newY -= speed;
            if(e.key === 'ArrowDown') newY += speed;
            if(e.key === 'ArrowLeft') newX -= speed;
            if(e.key === 'ArrowRight') newX += speed;
            
            // Check boundaries - account for soul size and border
            const soulHalfSize = 8;
            const borderWidth = 4;
            
            if(newX >= box.x + borderWidth + soulHalfSize && 
               newX <= box.x + box.width - borderWidth - soulHalfSize) {
                config.player.x = newX;
            }
            
            if(newY >= box.y + borderWidth + soulHalfSize && 
               newY <= box.y + box.height - borderWidth - soulHalfSize) {
                config.player.y = newY;
            }
            
            // Update soul position
            updateSoulPosition();
        }
        
        // Update player soul position
        function updateSoulPosition() {
            const soul = document.getElementById('player-soul');
            if (soul) {
                soul.style.left = (config.player.x - 8) + 'px'; // Center the soul (16x16)
                soul.style.top = (config.player.y - 8) + 'px';
            }
        }
        
        // Enter different battle modes
        function enterFightMode() {
            config.currentState = 'FIGHT';
            hideAllMenus();
            fightMenu.style.display = 'block';
            config.currentSubmenu = fightMenu;
            config.currentSelectedOption = 0;
            updateMenuSelection();
        }
        
        function enterActMode() {
            config.currentState = 'ACT_MONSTER_SELECT';
            hideAllMenus();
            actMonsterMenu.style.display = 'block';
            config.currentSubmenu = actMonsterMenu;
            config.currentSelectedOption = 0;
            updateMenuSelection();
        }
        
        function enterItemMode() {
            config.currentState = 'ITEM';
            hideAllMenus();
            itemMenu.style.display = 'block';
            config.currentSubmenu = itemMenu;
            config.currentSelectedOption = 0;
            updateMenuSelection();
        }
        
        function enterMercyMode() {
            config.currentState = 'MERCY';
            hideAllMenus();
            mercyMenu.style.display = 'block';
            config.currentSubmenu = mercyMenu;
            config.currentSelectedOption = 0;
            updateMenuSelection();
        }
        
        // Execute attack against selected monster
        function executeAttack() {
            const monster = config.monsters[config.currentSelectedMonster];
            
            // Hide menu and show attack animation
            hideAllMenus();
            
            // Show attack target line
            const monsterElement = document.getElementById(`monster${config.currentSelectedMonster + 1}`);
            const monsterRect = monsterElement.getBoundingClientRect();
            const slashElement = document.querySelector('.slash');
            
            // Position slash based on selected monster
            slashElement.style.left = `${monsterRect.left - 10}px`;
            slashElement.style.top = `${monsterRect.top + 40}px`;
            slashElement.style.display = 'block';
            
            // Play attack sound
            playSound(config.soundEffects.attack);
            
            // Animate slash
            setTimeout(() => {
                slashElement.style.display = 'none';
                
                // Calculate damage (simple formula)
                const damage = 5 + Math.floor(Math.random() * 5);
                
                // Apply damage to monster
                monster.hp = Math.max(0, monster.hp - damage);
                
                // Show damage result
                setDialogueText(`* You attacked ${monster.name}!\n* Dealt ${damage} damage!`);
                
                // Check if monster defeated
                if (monster.hp <= 0) {
                    // Monster defeated
                    monsterElement.style.opacity = 0;
                    setTimeout(() => {
                        setDialogueText(`* ${monster.name} was defeated!`);
                        setTimeout(() => {
                            // Check if all monsters defeated
                            if (config.monsters.every(m => m.hp <= 0)) {
                                setDialogueText(config.dialogues.spare);
                                setTimeout(() => {
                                    // Reset battle
                                    resetBattle();
                                }, 2000);
                            } else {
                                // Continue battle
                                setTimeout(() => {
                                    startEnemyTurn();
                                }, 1000);
                            }
                        }, 1500);
                    }, 1000);
                } else {
                    // Continue battle after showing damage
                    setTimeout(() => {
                        startEnemyTurn();
                    }, 1500);
                }
            }, 500);
        }
        
        // Execute ACT option
        function executeAct() {
            hideAllMenus();
            
            const actOption = ['Check', 'Pray', 'Defend', 'Control'][config.currentSelectedOption];
            const monster = config.monsters[config.currentSelectedMonster];
            
            switch(actOption) {
                case 'Check':
                    // Show monster check info
                    setDialogueText(config.dialogues.act.Check[config.currentSelectedMonster]);
                    break;
                case 'Pray':
                    // Heal player
                    const healAmount = 5;
                    config.player.hp = Math.min(config.player.maxHp, config.player.hp + healAmount);
                    updateHpDisplay();
                    playSound(config.soundEffects.heal);
                    setDialogueText(config.dialogues.act.Pray);
                    break;
                case 'Defend':
                    // Increase defense
                    config.player.defense = 2;
                    setDialogueText(config.dialogues.act.Defend);
                    break;
                case 'Control':
                    // Attempt to control monster
                    setDialogueText(config.dialogues.act.Control);
                    break;
            }
            
            // Continue battle after showing act result
            setTimeout(() => {
                startEnemyTurn();
            }, 1500);
        }
        
        // Use selected item
        function useItem() {
            hideAllMenus();
            
            const item = config.items[config.currentSelectedOption];
            
            // Heal player
            const healAmount = item.healAmount;
            const oldHp = config.player.hp;
            config.player.hp = Math.min(config.player.maxHp, config.player.hp + healAmount);
            updateHpDisplay();
            
            // Play heal sound
            playSound(config.soundEffects.heal);
            
            // Show item use result
            setDialogueText(`* You used ${item.name}.\n* Recovered ${config.player.hp - oldHp} HP!`);
            
            // Continue battle after showing item use result
            setTimeout(() => {
                startEnemyTurn();
            }, 1500);
        }
        
        // Execute mercy option
        function executeMercy() {
            hideAllMenus();
            
            const mercyOption = ['SPARE', 'FLEE'][config.currentSelectedOption];
            
            switch(mercyOption) {
                case 'SPARE':
                    // Try to spare monsters
                    setDialogueText('* You tried to SPARE the monsters.\n* But they cannot be spared yet.');
                    setTimeout(() => {
                        startEnemyTurn();
                    }, 1500);
                    break;
                case 'FLEE':
                    // Try to flee
                    const fleeChance = Math.random();
                    if (fleeChance > 0.5) {
                        // Successfully fled
                        setDialogueText('* You ran away successfully!');
                        setTimeout(() => {
                            resetBattle();
                        }, 1500);
                    } else {
                        // Failed to flee
                        setDialogueText('* Couldn\'t escape!');
                        setTimeout(() => {
                            startEnemyTurn();
                        }, 1500);
                    }
                    break;
            }
        }
        
        // Reset battle to initial state
        function resetBattle() {
            // Reset monsters
            config.monsters.forEach((monster, index) => {
                monster.hp = monster.maxHp;
                const monsterElement = document.getElementById(`monster${index + 1}`);
                monsterElement.style.opacity = 1;
            });
            
            // Reset player
            config.player.hp = config.player.maxHp;
            config.player.defense = 0;
            updateHpDisplay();
            
            // Reset battle state
            config.currentState = 'INTRO';
            setDialogueText(config.dialogues.intro);
        }
        
        // Create a menu to select monsters (for FIGHT or ACT)
        function createMonsterSelectionMenu() {
            // Update monster selection menu
            const monsterOptions = document.querySelectorAll('.monster-option');
            monsterOptions.forEach((option, index) => {
                option.textContent = `* ${config.monsters[index].name}`;
            });
        }